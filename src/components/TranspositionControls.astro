<!-- TranspositionControls.astro -->
<!-- Reusable transposition control component -->
---
interface Props {
  id: string;
  showHeader?: boolean;
  showRandomize?: boolean;
  compact?: boolean;
}

const { 
  id, 
  showHeader = false,
  showRandomize = true,
  compact = false 
} = Astro.props;

const instrumentId = `instrument-${id}`;
const wheelId = `wheel-${id}`;
const randomizeId = `randomize-${id}`;
---

<div class={`transposition-controls ${compact ? 'compact' : ''}`} data-control-id={id}>
  <!-- Locked Message (shown in Beginner Mode) -->
  <div class="locked-message-transposition">
    <div class="lock-icon-large">ðŸ”’</div>
    <h4 class="lock-title">Transposition Locked</h4>
    <p class="lock-description">
      Transposition is only available in <strong>Advanced Mode</strong>.
    </p>
    <p class="lock-instruction">
      To unlock, go to <strong>Settings</strong> on the home page and turn off <strong>Beginner Mode</strong>.
    </p>
    <a href="/" class="lock-home-btn">Go to Home Page</a>
  </div>

  <!-- Transposition Controls (shown in Advanced Mode) -->
  <div class="controls-content">
    {showHeader && (
      <div class="header">
        <h2>Transposition</h2>
        <p>Select instrument and concert key</p>
      </div>
    )}

  <!-- Instrument Picker -->
  <div class="control-group">
    <label class="label">Instrument</label>
    <select class="instrument-select" id={instrumentId}>
      <option value="Bb" selected>Bb Trumpet</option>
      <option value="C">C Trumpet</option>
      <option value="D">D Trumpet</option>
      <option value="Eb">Eb Trumpet</option>
    </select>
  </div>

  <!-- Key Wheel -->
  <div class="control-group">
    <label class="label">Concert Key</label>
    <div class="wheel-container">
      <div class="fade-top"></div>
      <div class="indicator"></div>
      <div class="wheel" id={wheelId}>
        <div class="wheel-padding"></div>
        <div class="wheel-item" data-key="A">A</div>
        <div class="wheel-item active" data-key="Bb">Bb</div>
        <div class="wheel-item" data-key="H">H</div>
        <div class="wheel-item" data-key="C">C</div>
        <div class="wheel-item" data-key="D">D</div>
        <div class="wheel-item" data-key="Eb">Eb</div>
        <div class="wheel-item" data-key="E">E</div>
        <div class="wheel-item" data-key="F">F</div>
        <div class="wheel-item" data-key="G">G</div>
        <div class="wheel-padding"></div>
      </div>
      <div class="fade-bottom"></div>
    </div>
  </div>

  <!-- Action Buttons -->
  {showRandomize && (
    <div class="control-group button-row">
      <button class="action-btn randomize-btn" id={randomizeId} type="button">
        <svg class="btn-icon" width="18" height="18" viewBox="0 0 24 24" fill="none">
          <rect x="3" y="3" width="18" height="18" rx="3" stroke="currentColor" stroke-width="2"/>
          <circle cx="8" cy="8" r="1.5" fill="currentColor"/>
          <circle cx="16" cy="8" r="1.5" fill="currentColor"/>
          <circle cx="8" cy="16" r="1.5" fill="currentColor"/>
          <circle cx="16" cy="16" r="1.5" fill="currentColor"/>
          <circle cx="12" cy="12" r="1.5" fill="currentColor"/>
        </svg>
        <span class="btn-text">Randomize</span>
      </button>
      <button class="action-btn reset-btn" id={`reset-${id}`} type="button">
        <svg class="btn-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="1 4 1 10 7 10"></polyline>
          <polyline points="23 20 23 14 17 14"></polyline>
          <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>
        </svg>
        <span class="btn-text">Reset</span>
      </button>
    </div>
  )}
  </div>
</div>

<script define:vars={{ id, showRandomize }}>
  window.addEventListener('DOMContentLoaded', () => {
    const controlId = id;
    const instrumentEl = document.getElementById(`instrument-${controlId}`);
    const wheelEl = document.getElementById(`wheel-${controlId}`);
    const randomizeEl = showRandomize ? document.getElementById(`randomize-${controlId}`) : null;
    const resetEl = showRandomize ? document.getElementById(`reset-${controlId}`) : null;

    if (!instrumentEl || !wheelEl) return;

    const items = wheelEl.querySelectorAll('.wheel-item');
    const keys = ['A', 'Bb', 'H', 'C', 'D', 'Eb', 'E', 'F', 'G'];
    const instruments = ['Bb', 'C', 'D', 'Eb'];
    let isAnimating = false;

    // Center the active item on load
    setTimeout(() => {
      const activeItem = wheelEl.querySelector('.wheel-item.active');
      if (activeItem) {
        centerItem(activeItem);
      }
    }, 100);

    // Click to select
    items.forEach(item => {
      item.addEventListener('click', () => {
        items.forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        centerItem(item);
        updateState();
        
        // Haptic feedback on click
        if (window.haptics) {
          window.haptics.trigger('light');
        }
      });
    });

    // Track user interaction for haptics
    let userHasInteracted = false;
    
    // Establish user interaction on first touch/click
    wheelEl.addEventListener('touchstart', () => {
      userHasInteracted = true;
    }, { once: true, passive: true });
    
    wheelEl.addEventListener('mousedown', () => {
      userHasInteracted = true;
    }, { once: true, passive: true });

    // Update active state based on scroll position
    let scrollTimeout;
    let lastScrollY = wheelEl.scrollTop;
    
    wheelEl.addEventListener('scroll', () => {
      // Check for active item change immediately during scroll
      const currentScrollY = wheelEl.scrollTop;
      const scrollDelta = Math.abs(currentScrollY - lastScrollY);
      
      // Only check if we've scrolled a meaningful amount
      if (scrollDelta > 5) {
        lastScrollY = currentScrollY;
        updateActiveItem(); // This will trigger haptic if item changed
      }
      
      // Also debounce for final settle
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        updateActiveItem();
      }, 150);
    });

    // Instrument change - use both 'change' and 'input' for better iOS support
    instrumentEl.addEventListener('focus', () => {
      console.log(`[transposition-controls-${controlId}] Instrument selector focused`);
    });
    
    instrumentEl.addEventListener('blur', () => {
      console.log(`[transposition-controls-${controlId}] Instrument selector blurred, value:`, instrumentEl.value);
    });
    
    instrumentEl.addEventListener('change', () => {
      console.log(`[transposition-controls-${controlId}] Instrument changed via change event:`, instrumentEl.value);
      updateState();
    });
    
    instrumentEl.addEventListener('input', () => {
      console.log(`[transposition-controls-${controlId}] Instrument changed via input event:`, instrumentEl.value);
      updateState();
    });
    
    // Handle touch events - try to manually trigger focus/click
    let selectTouchStartY = 0;
    let selectTouchStartX = 0;
    
    instrumentEl.addEventListener('touchstart', (e) => {
      console.log(`[transposition-controls-${controlId}] Instrument selector touched`);
      selectTouchStartY = e.touches[0].clientY;
      selectTouchStartX = e.touches[0].clientX;
    }, { passive: false });
    
    instrumentEl.addEventListener('touchend', (e) => {
      const touchEndY = e.changedTouches[0].clientY;
      const touchEndX = e.changedTouches[0].clientX;
      const deltaY = Math.abs(touchEndY - selectTouchStartY);
      const deltaX = Math.abs(touchEndX - selectTouchStartX);
      
      if (deltaY < 10 && deltaX < 10) {
        console.log(`[transposition-controls-${controlId}] Instrument selector tapped, attempting to open`);
        // Try to programmatically focus the element to open the picker
        instrumentEl.focus();
        instrumentEl.click();
        
        // iOS sometimes needs a delay
        setTimeout(() => {
          instrumentEl.focus();
        }, 50);
      }
    }, { passive: false });

    // Randomize
    if (randomizeEl) {
      console.log(`[transposition-controls-${controlId}] Randomize button found, attaching handler`);
      
      // Function to handle randomize action
      async function doRandomize() {
        console.log(`[transposition-controls-${controlId}] Randomize triggered`);
        if (isAnimating) {
          console.log(`[transposition-controls-${controlId}] Already animating, ignoring`);
          return;
        }
        
        isAnimating = true;
        randomizeEl.classList.add('spinning');
        
        const randInstrument = instruments[Math.floor(Math.random() * instruments.length)];
        const randKey = keys[Math.floor(Math.random() * keys.length)];
        
        console.log(`[transposition-controls-${controlId}] Randomizing to:`, { randInstrument, randKey });
        
        await Promise.all([
          animateInstrumentSpin(randInstrument),
          animateWheelSpin(randKey)
        ]);
        
        randomizeEl.classList.remove('spinning');
        isAnimating = false;
        
        updateState();
      }
      
      // Handle touch events for iOS
      let touchStartY = 0;
      let touchStartX = 0;
      
      randomizeEl.addEventListener('touchstart', (e) => {
        touchStartY = e.touches[0].clientY;
        touchStartX = e.touches[0].clientX;
        console.log(`[transposition-controls-${controlId}] Randomize button touched`);
      }, { passive: true });
      
      randomizeEl.addEventListener('touchend', (e) => {
        const touchEndY = e.changedTouches[0].clientY;
        const touchEndX = e.changedTouches[0].clientX;
        const deltaY = Math.abs(touchEndY - touchStartY);
        const deltaX = Math.abs(touchEndX - touchStartX);
        
        if (deltaY < 10 && deltaX < 10) {
          console.log(`[transposition-controls-${controlId}] Randomize button tapped`);
          doRandomize();
        }
      }, { passive: true });
      
      // Also keep click handler for desktop
      randomizeEl.addEventListener('click', async (e) => {
        console.log(`[transposition-controls-${controlId}] Randomize button clicked`);
        doRandomize();
      });
    } else {
      console.warn(`[transposition-controls-${controlId}] Randomize button not found!`);
    }

    // Reset
    if (resetEl) {
      function doReset() {
        console.log(`[transposition-controls-${controlId}] Reset triggered`);
        // Reset to Bb trumpet in Bb
        instrumentEl.value = 'Bb';
        const targetItem = Array.from(items).find(i => i.dataset.key === 'Bb');
        if (targetItem) {
          items.forEach(i => i.classList.remove('active'));
          targetItem.classList.add('active');
          centerItem(targetItem);
        }
        updateState();
      }
      
      // Handle touch events for iOS
      let touchStartY = 0;
      let touchStartX = 0;
      
      resetEl.addEventListener('touchstart', (e) => {
        touchStartY = e.touches[0].clientY;
        touchStartX = e.touches[0].clientX;
      }, { passive: true });
      
      resetEl.addEventListener('touchend', (e) => {
        const touchEndY = e.changedTouches[0].clientY;
        const touchEndX = e.changedTouches[0].clientX;
        const deltaY = Math.abs(touchEndY - touchStartY);
        const deltaX = Math.abs(touchEndX - touchStartX);
        
        if (deltaY < 10 && deltaX < 10) {
          doReset();
        }
      }, { passive: true });
      
      // Also keep click handler for desktop
      resetEl.addEventListener('click', () => {
        doReset();
      });
    }

    function centerItem(item) {
      const wheelCenter = wheelEl.offsetHeight / 2;
      const itemTop = item.offsetTop;
      const itemHeight = item.offsetHeight;
      const itemCenter = itemTop + itemHeight / 2;

      wheelEl.scrollTo({
        top: itemCenter - wheelCenter,
        behavior: 'smooth'
      });
    }

    // Track previous active item for haptic feedback
    let previousActiveKey = null;

    function updateActiveItem() {
      const wheelCenter = wheelEl.scrollTop + wheelEl.offsetHeight / 2;
      
      let closestItem = null;
      let closestDistance = Infinity;

      items.forEach(item => {
        const itemCenter = item.offsetTop + item.offsetHeight / 2;
        const distance = Math.abs(wheelCenter - itemCenter);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestItem = item;
        }
      });

      if (closestItem) {
        const newActiveKey = closestItem.dataset.key;
        
        // Trigger haptic feedback only when the active item actually changes
        if (newActiveKey !== previousActiveKey && previousActiveKey !== null) {
          if (window.haptics) {
            window.haptics.trigger('light');
          }
        }
        
        previousActiveKey = newActiveKey;
        items.forEach(i => i.classList.remove('active'));
        closestItem.classList.add('active');
        updateState();
      }
    }

    function updateState() {
      if (!window.TranspositionState) return;

      const activeKey = wheelEl.querySelector('.wheel-item.active')?.dataset.key;
      const instrument = instrumentEl.value;

      console.log('TranspositionControls updating state:', { instrument, key: activeKey });

      window.TranspositionState.update({
        instrument,
        key: activeKey,
        source: controlId
      });

      // Also dispatch the transposition:change event for game logic
      const changeEvent = new CustomEvent('transposition:change', {
        detail: { 
          instrument, 
          key: activeKey,
          enabled: true 
        },
        bubbles: true,
        composed: true
      });
      console.log('Dispatching transposition:change event:', changeEvent.detail);
      document.dispatchEvent(changeEvent);
      window.dispatchEvent(changeEvent);
    }

    // Listen for changes from other controls
    function syncFromState(event) {
      const { instrument, key, source } = event.detail;
      
      // Don't sync if this control triggered the change
      if (source === controlId) return;

      // Update instrument
      if (instrumentEl.value !== instrument) {
        instrumentEl.value = instrument;
      }

      // Update key
      const currentActive = wheelEl.querySelector('.wheel-item.active');
      if (currentActive?.dataset.key !== key) {
        const targetItem = Array.from(items).find(i => i.dataset.key === key);
        if (targetItem) {
          items.forEach(i => i.classList.remove('active'));
          targetItem.classList.add('active');
          centerItem(targetItem);
        }
      }
    }

    function animateInstrumentSpin(finalValue, duration = 1000) {
      return new Promise((resolve) => {
        const spinInterval = 80;
        const spinTimer = setInterval(() => {
          const randomInstrument = instruments[Math.floor(Math.random() * instruments.length)];
          instrumentEl.value = randomInstrument;
        }, spinInterval);
        
        setTimeout(() => {
          clearInterval(spinTimer);
          instrumentEl.value = finalValue;
          resolve();
        }, duration);
      });
    }

    function animateWheelSpin(finalKey, duration = 1200) {
      return new Promise((resolve) => {
        const wheelItems = Array.from(items);
        const startTime = Date.now();
        const startScroll = wheelEl.scrollTop;

        const finalItem = wheelItems.find(i => i.dataset.key === finalKey);
        if (!finalItem) {
          resolve();
          return;
        }

        const containerCenter = wheelEl.offsetHeight / 2;
        const itemTop = finalItem.offsetTop;
        const itemHeight = finalItem.offsetHeight;
        const itemCenter = itemTop + itemHeight / 2;

        const maxScroll = wheelEl.scrollHeight - wheelEl.clientHeight;
        const targetScroll = Math.min(Math.max(itemCenter - containerCenter, 0), maxScroll);

        const numSpins = 3;
        const extraDistance = wheelEl.scrollHeight * numSpins;
        const totalDistance = extraDistance + (targetScroll - startScroll);

        const animate = () => {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const eased = 1 - Math.pow(1 - progress, 4);

          if (progress < 0.7) {
            const currentDistance = totalDistance * eased;
            wheelEl.scrollTop = (startScroll + currentDistance) % (wheelEl.scrollHeight - wheelEl.clientHeight);
          } else {
            const landingProgress = (progress - 0.7) / 0.3;
            const landingEase = 1 - Math.pow(1 - landingProgress, 3);
            wheelEl.scrollTop = startScroll + (targetScroll - startScroll) * landingEase;
          }

          const speed = progress < 0.7 ? 1 : (1 - ((progress - 0.7) / 0.3));
          const blurAmount = speed * 4;
          wheelItems.forEach(item => {
            item.style.filter = `blur(${blurAmount}px)`;
          });

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            wheelEl.scrollTop = targetScroll;
            wheelItems.forEach(item => {
              item.style.filter = 'blur(0px)';
            });
            
            setTimeout(() => {
              items.forEach(i => i.classList.remove('active'));
              finalItem.classList.add('active');
              resolve();
            }, 100);
          }
        };

        requestAnimationFrame(animate);
      });
    }

    // Listen for state sync from other controls
    window.addEventListener('transposition:sync', syncFromState);

    // Check transposition enabled state and show/hide locked message
    const controlsContainer = document.querySelector(`[data-control-id="${controlId}"]`);
    const lockedMessage = controlsContainer?.querySelector('.locked-message-transposition');
    const controlsContent = controlsContainer?.querySelector('.controls-content');
    
    function updateLockedState() {
      const isEnabled = localStorage.getItem('transposition-enabled') === 'true';
      
      if (lockedMessage && controlsContent) {
        if (isEnabled) {
          // Advanced Mode - show controls
          lockedMessage.style.display = 'none';
          controlsContent.style.display = 'block';
        } else {
          // Beginner Mode - show locked message
          lockedMessage.style.display = 'flex';
          controlsContent.style.display = 'none';
        }
      }
    }
    
    // Check initial state
    updateLockedState();
    
    // Listen for transposition enabled/disabled events
    window.addEventListener('transposition:enabled', (e) => {
      updateLockedState();
    });

    // Initial state sync
    setTimeout(() => {
      console.log('TranspositionControls initializing for:', controlId);
      updateLockedState();
      if (window.TranspositionState) {
        updateState();
      } else {
        console.warn('TranspositionState not available yet');
      }
    }, 100);
  });
</script>

<style>
  .transposition-controls {
    width: 100%;
    position: relative;
  }

  /* Locked Message */
  .locked-message-transposition {
    display: none;
    flex-direction: column;
    align-items: center;
    text-align: center;
    padding: 32px 24px;
  }

  .lock-icon-large {
    font-size: 3rem;
    margin-bottom: 12px;
    opacity: 0.8;
  }

  .lock-title {
    font-size: 1.25rem;
    font-weight: 800;
    color: #1e293b;
    margin: 0 0 8px 0;
    letter-spacing: -0.02em;
  }

  .lock-description {
    font-size: 0.9rem;
    color: #475569;
    margin: 0 0 6px 0;
    line-height: 1.5;
  }

  .lock-description strong {
    color: #1e293b;
    font-weight: 700;
  }

  .lock-instruction {
    font-size: 0.85rem;
    color: #64748b;
    margin: 0 0 18px 0;
    line-height: 1.5;
  }

  .lock-instruction strong {
    color: #475569;
    font-weight: 600;
  }

  .lock-home-btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 10px 20px;
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: white;
    text-decoration: none;
    font-weight: 600;
    font-size: 0.95rem;
    border-radius: 12px;
    border: 1.5px solid rgba(16, 185, 129, 0.3);
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    transition: all 0.2s ease;
  }

  .lock-home-btn:hover {
    box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
    transform: translateY(-1px);
  }

  .lock-home-btn:active {
    transform: scale(0.98);
  }

  /* Controls Content */
  .controls-content {
    display: flex;
    flex-direction: column;
    pointer-events: auto;
    position: relative;
  }

  .header {
    text-align: center;
    margin-bottom: 32px;
  }

  .header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    color: #1e293b;
    margin-bottom: 8px;
  }

  .header p {
    font-size: 0.875rem;
    color: #64748b;
  }

  .control-group {
    margin-bottom: 18px;
    pointer-events: auto;
    position: relative;
    order: 2;
  }

  /* Instrument selector goes first (top) */
  .control-group:first-of-type {
    order: 1;
  }

  /* Buttons go last (bottom) */
  .control-group.button-row {
    order: 3;
  }

  .control-group:last-child {
    margin-bottom: 0;
  }

  .label {
    display: block;
    text-align: center;
    margin-bottom: 8px;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #64748b;
    font-weight: 700;
  }

  /* Instrument Select */
  .instrument-select {
    width: 100%;
    padding: 10px 14px;
    font-size: 0.95rem;
    font-weight: 600;
    border: 2px solid #e2e8f0;
    border-radius: 10px;
    background: #ffffff;
    color: #1e293b;
    cursor: pointer;
    transition: all 0.2s ease;
    /* Use menulist appearance on iOS to ensure native picker works */
    -webkit-appearance: menulist;
    -moz-appearance: none;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%2364748b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 16px center;
    padding-right: 44px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    -webkit-tap-highlight-color: rgba(18, 144, 142, 0.3);
    touch-action: manipulation;
    position: relative;
    z-index: 10;
    pointer-events: auto;
    /* Ensure iOS can interact with it */
    -webkit-user-select: auto;
    user-select: auto;
  }

  .instrument-select:hover {
    border-color: #cbd5e1;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
  }

  .instrument-select:focus {
    outline: none;
    border-color: #12908e;
    box-shadow: 0 0 0 3px rgba(18, 144, 142, 0.15);
  }

  .instrument-select option {
    background: #ffffff;
    color: #1e293b;
  }

  /* Wheel Container */
  .wheel-container {
    position: relative;
    width: 100%;
    height: 160px;
    background: #ffffff;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 
      0 1px 3px rgba(0, 0, 0, 0.05),
      inset 0 1px 2px rgba(0, 0, 0, 0.02);
  }

  .wheel {
    height: 100%;
    overflow-y: scroll;
    scroll-snap-type: y mandatory;
    scrollbar-width: none;
    -ms-overflow-style: none;
    cursor: grab;
  }

  .wheel:active {
    cursor: grabbing;
  }

  .wheel::-webkit-scrollbar {
    display: none;
  }

  .wheel-padding {
    height: 55px;
    flex-shrink: 0;
  }

  .wheel-item {
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    font-weight: 600;
    color: #cbd5e1;
    scroll-snap-align: center;
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
  }

  .wheel-item:hover {
    color: #94a3b8;
  }

  .wheel-item.active {
    color: #12908e;
    font-size: 1.5rem;
    font-weight: 700;
  }

  /* Center indicator */
  .indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: calc(100% - 48px);
    height: 40px;
    border-top: 2px solid rgba(18, 144, 142, 0.2);
    border-bottom: 2px solid rgba(18, 144, 142, 0.2);
    pointer-events: none;
    z-index: 1;
    background: linear-gradient(to bottom,
      transparent 0%,
      rgba(18, 144, 142, 0.03) 50%,
      transparent 100%);
  }

  /* Fade masks */
  .fade-top,
  .fade-bottom {
    position: absolute;
    left: 0;
    right: 0;
    height: 55px;
    pointer-events: none;
    z-index: 2;
  }

  .fade-top {
    top: 0;
    background: linear-gradient(to bottom,
      rgba(255, 255, 255, 1) 0%,
      rgba(255, 255, 255, 0.9) 40%,
      transparent 100%);
  }

  .fade-bottom {
    bottom: 0;
    background: linear-gradient(to top,
      rgba(255, 255, 255, 1) 0%,
      rgba(255, 255, 255, 0.9) 40%,
      transparent 100%);
  }

  /* Action Buttons */
  .button-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }

  .action-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 10px 12px;
    border: none;
    border-radius: 10px;
    font-weight: 700;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 
      0 2px 8px rgba(0, 0, 0, 0.1),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
  }

  .randomize-btn {
    background: linear-gradient(135deg, #12908e 0%, #0d7270 100%);
    color: #ffffff;
  }

  .randomize-btn:hover {
    transform: translateY(-2px);
    box-shadow: 
      0 4px 16px rgba(18, 144, 142, 0.3),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
  }

  .reset-btn {
    background: linear-gradient(135deg, #64748b 0%, #475569 100%);
    color: #ffffff;
  }

  .reset-btn:hover {
    transform: translateY(-2px);
    box-shadow: 
      0 4px 16px rgba(100, 116, 139, 0.3),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
  }

  .action-btn:active {
    transform: translateY(0);
  }

  .action-btn.spinning {
    animation: btnPulse 0.6s ease-in-out infinite;
  }

  @keyframes btnPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
  }

  .btn-icon {
    flex-shrink: 0;
  }

  .action-btn.spinning .btn-icon {
    animation: diceRoll 0.3s ease-in-out infinite;
  }

  @keyframes diceRoll {
    0%, 100% { transform: rotate(0deg); }
    25% { transform: rotate(-12deg); }
    75% { transform: rotate(12deg); }
  }

  /* Compact mode */
  .transposition-controls.compact .control-group {
    margin-bottom: 20px;
  }

  .transposition-controls.compact .wheel-container {
    height: 200px;
  }
</style>