---
import { ViewTransitions } from 'astro:transitions';
import Footer from "../components/Footer.astro";
import TranspositionPanel from "../components/TranspositionPanel.astro";
import UserSettings from "../components/UserSettings.astro";
import "../styles/tailwind.css";

const { showTransposition = false, isHomepage = false } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    
    <!-- Prevent white flash with theme color -->
    <meta name="theme-color" content="#182134" />
    
    <!-- iOS PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    
    <!-- View Transitions for smooth page changes -->
    <meta name="view-transition" content="same-origin" />
    
    <title>Astro Music Game</title>
    
    <!-- Inline critical CSS to prevent white flash -->
    <style>
      html, body {
        background-color: #182134;
        background: linear-gradient(135deg, 
          #c4421a 0%, 
          #ff8c00 12%, 
          #ffa500 20%, 
          #182134 35%, 
          #374661 50%, 
          #12908e 75%, 
          #16594a 100%);
      }
    </style>

    <!-- Tailwind CSS -->
  <link rel="stylesheet" href="/global.css" />
  
  <!-- Astro View Transitions for smooth page navigation -->
  <ViewTransitions />
  
  <!-- View Transitions lifecycle handlers -->
  <script is:inline>
    // Reinitialize everything after View Transitions navigation
    let vtNavigationCount = 0;
    let lastGamePath = null;
    
    // Clear any stuck button states before navigation starts
    document.addEventListener('astro:before-swap', () => {
      console.log('[VT] Before swap - clearing button states');
      
      // Check if we're leaving a game page
      const currentPath = window.location.pathname;
      const isLeavingGame = currentPath.includes('/game/');
      
      if (isLeavingGame) {
        console.log('[VT] Leaving game page - triggering cleanup');
        // Dispatch game cleanup event
        const cleanupEvent = new Event('game:cleanup');
        window.dispatchEvent(cleanupEvent);
        document.dispatchEvent(cleanupEvent);
      }
      
      // Clear all active buttons
      document.querySelectorAll('.gp-btn.active, .footer-btn.touching').forEach(btn => {
        btn.classList.remove('active', 'touching');
        btn.setAttribute('aria-pressed', 'false');
      });
      
      // Clear any active touch mappings
      if (window.touchMap) {
        window.touchMap.clear();
      }
      
      // Clear any active keyboard states
      if (window.activeKeys) {
        window.activeKeys.clear();
      }
    });
    
    document.addEventListener('astro:page-load', () => {
      vtNavigationCount++;
      const currentPath = window.location.pathname;
      const wasGamePage = lastGamePath && lastGamePath.includes('/game/');
      const isGamePage = currentPath.includes('/game/');
      
      console.log('[VT] Page loaded/swapped #' + vtNavigationCount + ' path: ' + currentPath + ' (from game: ' + wasGamePage + ')');
      
      // If navigating to a game page (from anywhere), do a full reload
      // Game pages have complex module scripts that need to run fresh
      if (isGamePage && vtNavigationCount > 1) {
        console.log('[VT] Game page detected, doing full reload');
        window.location.href = currentPath + window.location.search;
        return;
      }
      
      // If coming FROM a game page, we need to reset initialization flags
      // because the game page did a full reload which reset global state
      if (wasGamePage && !isGamePage) {
        console.log('[VT] Coming from game page, resetting initialization flags');
        window.footerInitialized = false;
        
        // Clear all button states after coming from game
        setTimeout(function() {
          document.querySelectorAll('.gp-btn.active, .footer-btn.touching').forEach(btn => {
            btn.classList.remove('active', 'touching');
            btn.setAttribute('aria-pressed', 'false');
          });
        }, 10);
        
        // Give the DOM a moment to settle, then dispatch DOMContentLoaded to reinitialize
        setTimeout(function() {
          console.log('[VT] Dispatching DOMContentLoaded to reinitialize footer');
          const domEvent = new Event('DOMContentLoaded', { bubbles: true });
          document.dispatchEvent(domEvent);
        }, 50);
      }
      
      lastGamePath = currentPath;
      
      // For normal non-game navigation, components reinitialize automatically
      if (vtNavigationCount > 1 && !isGamePage && !wasGamePage) {
        console.log('[VT] Normal navigation between non-game pages');
        
        // Still clear button states on normal navigation
        setTimeout(function() {
          document.querySelectorAll('.gp-btn.active, .footer-btn.touching').forEach(btn => {
            btn.classList.remove('active', 'touching');
            btn.setAttribute('aria-pressed', 'false');
          });
        }, 10);
      } else if (vtNavigationCount === 1) {
        console.log('[VT] First load, using natural initialization');
      }
    });
  </script>
  
  <!-- Haptic Feedback Manager -->
  <script is:inline src="/scripts/HapticManager.js"></script>
  </head>
  <body class="min-h-screen flex flex-col">
    <!-- Loading overlay to prevent white flashes -->
    <div id="page-loader" class="page-loader">
      <div class="loader-spinner"></div>
    </div>
    
    <div class="background-gradient" transition:persist></div>
    <div class="floating-orbs" transition:persist>
      <div class="orb orb-1"></div>
      <div class="orb orb-2"></div>
      <div class="orb orb-3"></div>
    </div>
    <slot />
    {showTransposition && (<TranspositionPanel />)}
    <UserSettings />
    <Footer showTransposition={showTransposition} isHomepage={isHomepage} />
  {showTransposition && (<script type="module" src="/scripts/transposition-panel.js"></script>)}
  {showTransposition && (<script is:inline>
    // Initialize transposition UI state on page load
    (function() {
      function initTranspositionUI() {
        const isEnabled = localStorage.getItem('transposition-enabled') === 'true';
        const transpositionBtn = document.getElementById('transposition-toggle');
        // Only manage button visibility - TranspositionControls handles locked state internally
        if (transpositionBtn) {
          transpositionBtn.style.display = isEnabled ? '' : 'none';
        }
      }
      // Run immediately if DOM is ready
      if (document.readyState !== 'loading') {
        initTranspositionUI();
      }
      // Also run on DOMContentLoaded
      document.addEventListener('DOMContentLoaded', initTranspositionUI);
      // Run after a delay to catch any dynamically added elements
      setTimeout(initTranspositionUI, 200);
      // React to settings changes while the page is open
      window.addEventListener('transposition:enabled', (ev) => {
        const transpositionBtn = document.getElementById('transposition-toggle');
        if (!transpositionBtn) return;
        try {
          const enabled = !!(ev && ev.detail && ev.detail.enabled);
          transpositionBtn.style.display = enabled ? '' : 'none';
        } catch (_) {}
      });
      // If transposition activity is detected, ensure button is visible
      const ensureVisible = () => {
        const transpositionBtn = document.getElementById('transposition-toggle');
        if (!transpositionBtn) return;
        if (localStorage.getItem('transposition-enabled') === 'true') {
          transpositionBtn.style.display = '';
        }
      };
      window.addEventListener('transposition:change', ensureVisible);
      window.addEventListener('transposition:sync', ensureVisible);
    })();
  </script>)}
  <script is:inline>
    // Custom navigation disabled - View Transitions handles this
    /*
    // Fix absolute /-prefixed navigation for Capacitor/WKWebView by rewriting to root-based URLs.
    (function () {
      function isExternal(h) {
        return /^(https?:|mailto:|tel:|#|javascript:)/.test(h);
      }
      function getAppRoot() {
        const href = window.location.href || '';
        if (/^capacitor:\/\//i.test(href)) return 'capacitor://localhost/';
        if (/^https?:\/\//i.test(href)) return (window.location.origin || '').replace(/\/$/, '') + '/';
        const m = href.match(/^(.*?\/public\/)/);
        if (m && m[1]) return m[1];
        return '/';
      }
      function buildRelativeUrlFromRootHref(href) {
        var base = getAppRoot();
        
        // Special case: root path
        if (href === '/') {
          console.log('[nav] Root path detected, returning base + index.html');
          return base + 'index.html';
        }
        
        var raw = href.slice(1);
        var hash = '';
        var hashIndex = raw.indexOf('#');
        if (hashIndex !== -1) { hash = raw.slice(hashIndex); raw = raw.slice(0, hashIndex); }
        var search = '';
        var qIndex = raw.indexOf('?');
        var pathname = raw;
        if (qIndex !== -1) { search = raw.slice(qIndex); pathname = raw.slice(0, qIndex); }
        
        // Handle empty pathname
        if (pathname === '' || pathname === '/') {
          pathname = 'index.html';
        } else if (!pathname.includes('.') && !pathname.endsWith('/')) {
          pathname = pathname + '/index.html';
        } else if (pathname.endsWith('/')) {
          pathname = pathname + 'index.html';
        }
        
        return base + pathname + search + hash;
      }
      document.addEventListener('click', function (e) {
        try {
          var a = e.target && e.target.closest ? e.target.closest('a') : null;
          if (!a) return;
          var href = a.getAttribute('href');
          console.log('[nav] Click detected on link:', href, 'Element:', a);
          if (!href || isExternal(href)) {
            console.log('[nav] Skipping - no href or external link');
            return;
          }
          if (href.startsWith('/')) {
            console.log('[nav] Internal link detected, preventing default and starting navigation');
            e.preventDefault();
            
            // Show loader during navigation
            var loader = document.getElementById('page-loader');
            if (loader) {
              loader.classList.remove('hidden');
              console.log('[nav] Loader shown');
              
              // Safety timeout - always hide loader after 3 seconds
              setTimeout(function() {
                console.log('[nav] Safety timeout - hiding loader');
                loader.classList.add('hidden');
                document.body.classList.remove('navigating');
              }, 3000);
            }
            
            // Mark body as navigating to hide overlays
            document.body.classList.add('navigating');
            
            // Add swoop-out animation to main content
            var main = document.querySelector('main');
            console.log('[nav] Found main element:', !!main);
            
            if (!main) {
              console.log('[nav] No main element found, using standard navigation');
              // No main element, just do standard navigation with loader
              var newUrl = buildRelativeUrlFromRootHref(href);
              console.log('[nav] Navigating to:', newUrl);
              window.location.href = newUrl;
              return;
            }
            
            if (main) {
              main.style.animation = 'swoopOut 0.25s cubic-bezier(0.4, 0, 1, 1) forwards';
              
              // Wait for animation, then fetch and replace content
              setTimeout(function() {
                var newUrl = buildRelativeUrlFromRootHref(href);
                console.log('[nav] Navigating from', href, 'to', newUrl);
                
                // Fetch the new page
                fetch(newUrl)
                  .then(function(response) { 
                    console.log('[nav] Fetch response:', response.status, response.url);
                    return response.text(); 
                  })
                  .then(function(html) {
                    // Parse the HTML
                    var parser = new DOMParser();
                    var doc = parser.parseFromString(html, 'text/html');
                    var newMain = doc.querySelector('main');
                    console.log('[nav] Found new main:', !!newMain);
                    
                    if (newMain && main) {
                      // Check for new stylesheets and add them if needed
                      var newStylesheets = doc.querySelectorAll('link[rel="stylesheet"]');
                      var existingHrefs = Array.from(document.querySelectorAll('link[rel="stylesheet"]')).map(function(link) {
                        return link.href;
                      });
                      
                      newStylesheets.forEach(function(stylesheet) {
                        if (!existingHrefs.includes(stylesheet.href)) {
                          console.log('[nav] Loading new stylesheet:', stylesheet.href);
                          var newLink = document.createElement('link');
                          newLink.rel = 'stylesheet';
                          newLink.href = stylesheet.href;
                          document.head.appendChild(newLink);
                        }
                      });
                      
                      // Replace entire main element to preserve all attributes and structure
                      var parent = main.parentNode;
                      var clonedMain = newMain.cloneNode(true);
                      parent.replaceChild(clonedMain, main);
                      main = clonedMain;
                      
                      // Update title
                      var newTitle = doc.querySelector('title');
                      if (newTitle) document.title = newTitle.textContent;
                      
                      // Update URL without reload
                      history.pushState({}, '', newUrl);
                      
                      // Remove navigating class and trigger swoop-in
                      document.body.classList.remove('navigating');
                      main.style.animation = 'swoopIn 0.35s cubic-bezier(0.16, 1, 0.3, 1)';
                      
                      // Hide loader after navigation (with multiple fallbacks)
                      if (loader) {
                        loader.classList.add('hidden');
                      }
                      
                      // Trigger DOMContentLoaded for the new page content
                      setTimeout(function() {
                        var event = new Event('DOMContentLoaded', { bubbles: true, cancelable: false });
                        document.dispatchEvent(event);
                      }, 50);
                      
                      // Execute any inline scripts in the new content
                      var scripts = main.querySelectorAll('script');
                      scripts.forEach(function(oldScript) {
                        var scriptType = oldScript.getAttribute('type');
                        var scriptSrc = oldScript.getAttribute('src') || '';
                        
                        // Skip astro dev toolbar scripts to avoid re-registration errors
                        if (scriptSrc.includes('astro') || scriptSrc.includes('vite')) {
                          return;
                        }
                        
                        // Execute all other scripts (including type="module")
                        var newScript = document.createElement('script');
                        Array.from(oldScript.attributes).forEach(function(attr) {
                          newScript.setAttribute(attr.name, attr.value);
                        });
                        if (oldScript.src) {
                          newScript.src = oldScript.src;
                        } else {
                          newScript.textContent = oldScript.textContent;
                        }
                        oldScript.parentNode.replaceChild(newScript, oldScript);
                      });
                    } else {
                      console.log('[nav] Main element missing, falling back to full page load');
                      // Fallback to full page load if parsing fails
                      window.location.href = newUrl;
                    }
                  })
                  .catch(function(err) {
                    console.error('[nav] Navigation error:', err);
                    // Fallback to full page load on error
                    window.location.href = newUrl;
                  });
              }, 250);
            } else {
              console.log('[nav] No main element found, falling back to full page load');
              // No main element, just do a regular navigation
              window.location.href = buildRelativeUrlFromRootHref(href);
            }
          }
        } catch (err) {
          console.warn('[nav] nav-rewrite error', err);
        }
      }, false);
    })();
    */
  </script>
  <script is:inline>
    // Remove navigating class on page load to show content
    (function() {
      // Remove immediately
      document.body.classList.remove('navigating');
      
      // Also remove on DOMContentLoaded
      document.addEventListener('DOMContentLoaded', function() {
        document.body.classList.remove('navigating');
      });
    })();
  </script>
  <script is:inline>
    // Hide page loader after page loads
    (function() {
      function hideLoader() {
        var loader = document.getElementById('page-loader');
        if (loader) {
          loader.classList.add('hidden');
          console.log('[loader] Hidden');
        }
      }
      
      // Maximum timeout - ALWAYS hide after 2 seconds no matter what
      setTimeout(function() {
        console.log('[loader] Maximum timeout reached, forcing hide');
        hideLoader();
      }, 2000);
      
      // Hide immediately if already loaded
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(hideLoader, 100);
      }
      
      // Also hide on DOMContentLoaded
      document.addEventListener('DOMContentLoaded', function() {
        setTimeout(hideLoader, 100);
      });
      
      // Fallback - hide after window load
      window.addEventListener('load', function() {
        setTimeout(hideLoader, 100);
      });
      
      // Hide after View Transitions navigation
      document.addEventListener('astro:page-load', function() {
        console.log('[loader] astro:page-load - hiding loader');
        setTimeout(hideLoader, 100);
      });
    })();
  </script>
  <script is:inline>
    // Footer touch feedback only - let global nav handler do the navigation
    (function initFooter() {
      // Mark if already initialized to prevent duplicate listeners
      if (window.footerInitialized) {
        console.log('[footer] Already initialized, skipping');
        return;
      }
      
      console.log('[footer] Initializing footer touch feedback');
      window.footerInitialized = true;
      
      // Clear any stuck button states immediately when initializing
      setTimeout(function() {
        document.querySelectorAll('.gp-btn.active, .footer-btn.touching').forEach(btn => {
          btn.classList.remove('active', 'touching');
          btn.setAttribute('aria-pressed', 'false');
        });
      }, 10);
      
      // Wait for footer to be in DOM
      function attachFooterListeners() {
        var footer = document.querySelector('.footer');
        if (!footer) {
          console.log('[footer] Footer not found, retrying...');
          setTimeout(attachFooterListeners, 100);
          return;
        }
        
        console.log('[footer] Footer found, attaching touch feedback listeners');
        
        // Track touch position to detect if it's a tap vs scroll
        var touchStartY = 0;
        var touchStartX = 0;
        
        footer.addEventListener('touchstart', function(e) {
          var btn = e.target && e.target.closest ? e.target.closest('.footer-btn') : null;
          if (btn) {
            btn.classList.add('touching');
            touchStartY = e.touches[0].clientY;
            touchStartX = e.touches[0].clientX;
            console.log('[footer] Touch started on button');
            
            // Trigger haptic feedback on button press
            if (window.haptics) {
              window.haptics.onButtonPress();
            }
          }
        }, { passive: true });
        
        footer.addEventListener('touchend', function(e) {
          var btn = e.target && e.target.closest ? e.target.closest('.footer-btn') : null;
          if (btn) {
            btn.classList.remove('touching');
            
            // Only trigger navigation if it wasn't a scroll/swipe
            var touchEndY = e.changedTouches[0].clientY;
            var touchEndX = e.changedTouches[0].clientX;
            var deltaY = Math.abs(touchEndY - touchStartY);
            var deltaX = Math.abs(touchEndX - touchStartX);
            
            if (deltaY < 10 && deltaX < 10) {
              console.log('[footer] Touch ended on button, dispatching click');
              // Dispatch a synthetic click event that will be caught by global handler
              var clickEvent = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window
              });
              btn.dispatchEvent(clickEvent);
            } else {
              console.log('[footer] Touch moved too much (scroll/swipe), ignoring');
            }
          }
        }, { passive: true });
        
        footer.addEventListener('touchcancel', function(e) {
          var btn = e.target && e.target.closest ? e.target.closest('.footer-btn') : null;
          if (btn) {
            btn.classList.remove('touching');
          }
        }, { passive: true });
      }
      
      // Start trying to attach listeners
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', attachFooterListeners);
      } else {
        attachFooterListeners();
      }
    })();
  </script>
  </body>
</html>

<style>
  /* Prevent white flash on page load */
  html {
    background: linear-gradient(135deg, 
      #c4421a 0%, 
      #ff8c00 12%, 
      #ffa500 20%, 
      #182134 35%, 
      #374661 50%, 
      #12908e 75%, 
      #16594a 100%);
    background-attachment: fixed;
  }

  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #333;
    position: relative;
    overflow-x: hidden;
    /* iOS safe area insets */
    padding-top: 0;
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    /* Optimize touch interactions */
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    /* Prevent white flash - keep background always visible */
    background: transparent;
  }

  /* Loading overlay to prevent white flash during navigation */
  .page-loader {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    opacity: 1;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    visibility: visible;
  }

  .page-loader.hidden {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
  }

  /* Spinner animation */
  .loader-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid rgba(255, 255, 255, 0.2);
    border-top-color: #ffffff;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Page content animations - swoop in and out */
  main {
    animation: swoopIn 0.35s cubic-bezier(0.16, 1, 0.3, 1);
  }

  @keyframes swoopIn {
    from {
      opacity: 0;
      transform: translateY(20px) scale(0.98);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  @keyframes swoopOut {
    from {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    to {
      opacity: 0;
      transform: translateY(-20px) scale(0.98);
    }
  }

  /* Hide overlays during page navigation */
  body.navigating #begingame-overlay,
  body.navigating #endgame-overlay,
  body.navigating #pause-overlay,
  body.navigating .transposition-overlay {
    display: none !important;
    opacity: 0 !important;
  }

  @keyframes slideInFade {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  /* Global touch optimization for all buttons and interactive elements */
  button, a, .gp-btn, [role="button"] {
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    user-select: none;
    -webkit-user-select: none;
  }

  /* Touch feedback for footer buttons */
  .footer-btn.touching {
    transform: translateX(-50%) scale(0.95) !important;
  }

  /* Background gradient animation - optimized for mobile */
.background-gradient {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, 
    #c4421a 0%, 
    #ff8c00 12%, 
    #ffa500 20%, 
    #182134 35%, 
    #374661 50%, 
    #12908e 75%, 
    #16594a 100%);
  background-size: 400% 400%;
  animation: gradientFlow 20s ease infinite;
  z-index: -2;
  will-change: background-position;
  backface-visibility: hidden;
}

@keyframes gradientFlow {
  0% { background-position: 0% 50%; }
  25% { background-position: 50% 25%; }
  50% { background-position: 100% 50%; }
  75% { background-position: 50% 75%; }
  100% { background-position: 0% 50%; }
}

/* Enhanced mobile experience with radial overlay */
@media (max-width: 768px) {
  .background-gradient {
    /* More dramatic diagonal for mobile */
    background: linear-gradient(160deg, 
      #c4421a 0%, 
      #ff8c00 15%, 
      #ffa500 25%, 
      #182134 40%, 
      #12908e 70%, 
      #16594a 100%);
    background-size: 300% 300%;
    animation: gradientFlowMobile 15s ease-in-out infinite;
  }
  
  @keyframes gradientFlowMobile {
    0% { background-position: 0% 0%; }
    33% { background-position: 100% 50%; }
    66% { background-position: 50% 100%; }
    100% { background-position: 0% 0%; }
  }
  
  /* Add subtle radial accent for depth on mobile */
  .background-gradient::after {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at 50% 40%, 
      rgba(18, 144, 142, 0.3) 0%, 
      transparent 50%);
    animation: pulseGlow 8s ease-in-out infinite;
  }
  
  @keyframes pulseGlow {
    0%, 100% { 
      opacity: 0.4;
      transform: scale(1);
    }
    50% { 
      opacity: 0.7;
      transform: scale(1.2);
    }
  }
}

/* Smaller mobile devices - even more dramatic */
@media (max-width: 480px) {
  .background-gradient {
    background: linear-gradient(170deg, 
      #c4421a 0%, 
      #ff8c00 20%, 
      #ffa500 30%, 
      #12908e 60%, 
      #182134 100%);
    background-size: 250% 250%;
    animation: gradientFlowSmall 12s ease-in-out infinite;
  }
  
  @keyframes gradientFlowSmall {
    0% { background-position: 0% 0%; }
    50% { background-position: 100% 100%; }
    100% { background-position: 0% 0%; }
  }
}
  

  /* Floating orbs */
  .floating-orbs {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: -1;
    pointer-events: none;
    will-change: transform;
    backface-visibility: hidden;
  }

  .orb {
    position: absolute;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(50px);
    animation: floatOrb 32s infinite ease-in-out;
    box-shadow: 
      0 0 60px rgba(255, 255, 255, 0.2),
      inset 0 0 40px rgba(255, 255, 255, 0.1);
  }

  .orb-1 {
    width: 500px;
    height: 500px;
    top: -250px;
    left: -250px;
    animation-delay: 0s;
    animation-duration: 32s;
  }

  .orb-2 {
    width: 400px;
    height: 400px;
    bottom: -200px;
    right: -200px;
    animation-delay: 7s;
    animation-duration: 40s;
  }

  .orb-3 {
    width: 450px;
    height: 450px;
    top: 40%;
    left: 50%;
    animation-delay: 14s;
    animation-duration: 36s;
  }

  @keyframes floatOrb {
    0%, 100% { 
      transform: translate(0, 0) scale(1);
      opacity: 0.6;
    }
    33% { 
      transform: translate(80px, -80px) scale(1.15);
      opacity: 0.8;
    }
    66% { 
      transform: translate(-50px, 50px) scale(0.85);
      opacity: 0.7;
    }
  }

  /* Glass effects for global use */
  :global(.glass-title) {
    background: rgba(255, 255, 255, 0.25);
    backdrop-filter: blur(20px) saturate(180%);
    border-radius: 20px;
    padding: 16px 32px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 
      0 8px 32px rgba(0, 0, 0, 0.12),
      inset 0 1px 0 rgba(255, 255, 255, 0.5);
    color: #ffffff;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  }

  :global(.glass-badge) {
    background: rgba(255, 255, 255, 0.3);
    backdrop-filter: blur(16px) saturate(180%);
    padding: 8px 16px;
    border-radius: 16px;
    border: 1px solid rgba(255, 255, 255, 0.5);
    color: #ffffff;
    font-size: 0.9rem;
    font-weight: 600;
    box-shadow: 
      0 4px 16px rgba(0, 0, 0, 0.15),
      inset 0 1px 0 rgba(255, 255, 255, 0.6);
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  }

  :global(.glass-debug) {
    background: rgba(0, 0, 0, 0.35);
    backdrop-filter: blur(12px);
    padding: 6px 12px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.25);
    color: #ffffff;
    font-size: 0.8rem;
    font-weight: 600;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  }

  :global(.glass-progress) {
    position: relative;
    width: 100%;
    height: 24px;
    background: rgba(0, 0, 0, 0.25);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 
      inset 0 2px 6px rgba(0, 0, 0, 0.4),
      0 4px 12px rgba(0, 0, 0, 0.15);
  }

  :global(#game-progress-fill) {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 0%;
    background: linear-gradient(90deg, #10b981 0%, #ffffff 50%, #ffffff 100%);
    box-shadow: 
      0 0 20px rgba(16, 185, 129, 0.6),
      inset 0 1px 0 rgba(255, 255, 255, 0.4);
    transition: width 220ms ease;
  }

  :global(#game-progress-text),
  :global(#game-progress-countdown) {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 0.85rem;
    font-weight: 800;
    color: #fff;
    pointer-events: none;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    letter-spacing: 0.5px;
    z-index: 10;
  }

  :global(.glass-controls) {
    display: flex;
    gap: 16px;
    align-items: center;
    background: rgba(255, 255, 255, 0.25);
    backdrop-filter: blur(20px) saturate(180%);
    padding: 12px 20px;
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 
      0 8px 32px rgba(0, 0, 0, 0.15),
      inset 0 1px 0 rgba(255, 255, 255, 0.5);
  }

  :global(.glass-btn) {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.3);
    backdrop-filter: blur(12px);
    border: 1.5px solid rgba(255, 255, 255, 0.5);
    border-radius: 14px;
    color: #fff;
    cursor: pointer;
    transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    box-shadow: 
      0 4px 16px rgba(0, 0, 0, 0.15),
      inset 0 1px 0 rgba(255, 255, 255, 0.6);
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    user-select: none;
    -webkit-user-select: none;
  }

  :global(.glass-btn::before) {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, 
      rgba(16, 185, 129, 0.4) 0%, 
      rgba(251, 146, 60, 0.4) 100%);
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  :global(.glass-btn:hover::before) {
    opacity: 1;
  }

  :global(.glass-btn:hover) {
    transform: translateY(-3px) scale(1.05);
    background: rgba(255, 255, 255, 0.4);
    border-color: rgba(255, 255, 255, 0.7);
    box-shadow: 
      0 8px 28px rgba(0, 0, 0, 0.25),
      0 0 25px rgba(16, 185, 129, 0.5),
      inset 0 1px 0 rgba(255, 255, 255, 0.7);
  }

  :global(.glass-btn:active) {
    transform: translateY(-1px) scale(0.98);
  }

  :global(.glass-btn svg) {
    flex-shrink: 0;
    position: relative;
    z-index: 1;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
  }

  /* Glass card container */
  :global(.glass-card) {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(20px) saturate(180%);
    border-radius: 20px;
    padding: 20px;
    border: 1px solid rgba(255, 255, 255, 0.4);
    box-shadow: 
      0 12px 40px rgba(0, 0, 0, 0.15),
      inset 0 1px 0 rgba(255, 255, 255, 0.5);
    transition: all 0.3s ease;
  }

  :global(.glass-card:hover) {
    transform: translateY(-4px);
    box-shadow: 
      0 16px 50px rgba(0, 0, 0, 0.2),
      inset 0 1px 0 rgba(255, 255, 255, 0.6);
  }

  /* Smooth entrance animations */
  @keyframes fadeInScale {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  :global(.glass-title),
  :global(.glass-controls) {
    animation: fadeInScale 0.6s ease-out;
  }

  :global(.glass-badge),
  :global(.glass-debug) {
    animation: fadeInScale 0.6s ease-out 0.2s both;
  }

  :global(.glass-card) {
    animation: fadeInUp 0.8s ease-out 0.3s both;
  }

  /* Responsive */
  @media (max-width: 640px) {
    .orb-1,
    .orb-2,
    .orb-3 {
      opacity: 0.5;
    }

    :global(.glass-controls) {
      gap: 12px;
      padding: 10px 16px;
    }

    :global(.glass-btn) {
      width: 44px;
      height: 44px;
    }

    :global(.glass-title) {
      font-size: 1.5rem;
      padding: 12px 24px;
    }
  }

  /* Touch device optimizations - faster, more dramatic feedback */
  @media (hover: none) and (pointer: coarse) {
    :global(.glass-btn) {
      transition: all 0.08s cubic-bezier(0.4, 0, 0.2, 1);
    }

    :global(.glass-btn:hover) {
      transform: none;
      background: rgba(255, 255, 255, 0.3);
    }

    :global(.glass-btn:active) {
      transform: scale(0.85) !important;
      background: rgba(255, 255, 255, 0.5) !important;
      border-color: rgba(255, 255, 255, 0.8) !important;
      box-shadow: 
        0 2px 8px rgba(0, 0, 0, 0.25),
        inset 0 2px 4px rgba(0, 0, 0, 0.2),
        0 0 20px rgba(16, 185, 129, 0.6) !important;
    }

    :global(.glass-card:hover) {
      transform: none;
    }

    :global(.glass-card:active) {
      transform: scale(0.98);
      background: rgba(255, 255, 255, 0.25);
    }
  }

  /* Reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .background-gradient,
    .orb,
    :global(.glass-title),
    :global(.glass-controls),
    :global(.glass-badge),
    :global(.glass-debug),
    :global(.glass-card) {
      animation: none !important;
    }

    :global(.glass-btn),
    :global(.glass-card) {
      transition: none !important;
    }
  }
</style>